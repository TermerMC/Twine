package net.termer.twine.utils;

import java.util.ArrayList;

import io.vertx.core.json.JsonObject;
import net.termer.twine.ServerManager;

/**
 * Utility class for chaining callbacks rather than nesting them.
 * @author termer
 * @since 1.0-alpha
 */
public class Callback {
	private Throwable _cause = null;
	private JsonObject _data = new JsonObject();
	private ArrayList<CallbackAction> _callbacks = new ArrayList<CallbackAction>();
	private ArrayList<CallbackAction> _failCallbacks = new ArrayList<CallbackAction>();
	private int _execIndex = 0;
	private boolean _async = false;
	
	/**
	 * Creates a new Callback object
	 * @since 1.0-alpha
	 */
	public Callback() {
		_async = false;
	}
	
	/**
	 * Creates a new Callback object
	 * @param async whether to run callbacks asynchronously rather than blocking. Keep in mind that this can greatly slow execution and is not generally recommended
	 * @since 1.0-alpha
	 */
	public Callback(boolean async) {
		_async = async;
	}
	
	/**
	 * Adds a callback
	 * @param action the callback
	 * @param fail the handler for any errors caught while executing the callback
	 * @return this Callback, to be used fluently
	 * @since 1.0-alpha
	 */
	public Callback then(CallbackAction action, CallbackAction fail) {
		_callbacks.add(action);
		_failCallbacks.add(fail);
		return this;
	}
	
	/**
	 * Returns data passed by other callbacks
	 * @return data passed by callbacks
	 * @since 1.0-alpha
	 */
	public JsonObject data() {
		return _data;
	}
	
	/**
	 * Passes a Throwable error and executes this callback's error handler.
	 * Calling fail().next() is permitted, so if you do not want the next callback to be executed, be sure to call end() in the failure callback.
	 * @param error the error that was caught
	 * @return this Callback, to be used fluently
	 * @since 1.0-alpha
	 */
	public Callback fail(Throwable error) {
		_cause = error;
		CallbackAction fail = _failCallbacks.get(_execIndex);
		if(_async && fail != null) {
			ServerManager.vertx().executeBlocking(f -> {
				fail.run(this);
			}, r -> {});
		} else if(fail == null) {
			_cause.printStackTrace();
		} else {
			fail.run(this);
		}
		
		return this;
	}
	
	/**
	 * Returns the Throwable passed by a fail() call in a callback. Null if none was passed
	 * @return The Throwable generated by a fail()
	 * @since 1.0-alpha
	 */
	public Throwable cause() {
		return _cause;
	}
	
	/**
	 * Executes the next callback, if any
	 * @return this Callback, to be used fluently
	 * @since 1.0-alpha
	 */
	public Callback next() {
		_execIndex++;
		if(_execIndex < _callbacks.size()) {
			CallbackAction cb = _callbacks.get(_execIndex);
			if(_async) {
				ServerManager.vertx().executeBlocking(f -> {
					try {
						cb.run(this);
					} catch(Exception e) {
						fail(e);
					}
				}, r -> {});
			} else {
				try {
					cb.run(this);
				} catch(Exception e) {
					fail(e);
				}
			}
		} else {
			this.notifyAll();
		}
		return this;
	}
	
	/**
	 * Clears all callbacks and ends all further execution.
	 * Should be used on the last callback in chain, as it signifies that all callbacks are finished.
	 * @since 1.0-alpha
	 */
	public void end() {
		System.out.println("ENDED");
		_callbacks.clear();
		_failCallbacks.clear();
		_execIndex = 0;
		this.notifyAll();
	}
	
	/**
	 * Executes all callbacks
	 * @return this Callback, to be used fluently
	 * @since 1.0-alpha
	 */
	public Callback execute() {
		System.out.println("execute() "+Thread.currentThread().getName());
		if(_callbacks.size() > 0) {
			ServerManager.vertx().executeBlocking(f -> {
				System.out.println("execute() async "+Thread.currentThread().getName());
				_callbacks.get(0).run(this);
			}, r -> {});
		}
		return this;
	}
	
	/**
	 * Simple interface for callbacks
	 * @author termer
	 * @since 1.0-alpha
	 */
	public interface CallbackAction {
		/**
		 * Performs an action
		 * @param cb the Callback object that's running this callback
		 * @since 1.0-alpha
		 */
		public void run(Callback cb);
	}
}